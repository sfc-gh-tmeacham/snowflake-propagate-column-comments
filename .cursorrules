# Snowflake Scripting Cursor Rules

## Variable Declaration and Assignment Rules

### 1. Variable Declaration Patterns
- Always declare variables in DECLARE blocks at the beginning of procedure/block
- Use `DECLARE variable_name TYPE;` for declarations
- Use `variable_name := value;` for assignment to declared variables
- Use `LET variable_name := value;` only for local variables not declared in DECLARE block

### 2. Error Message Variables
- Always declare `err_msg VARCHAR;` in DECLARE blocks if using error handling
- Never use `LET err_msg :=` if already declared - use direct assignment instead

## Loop and Cursor Rules

### 3. FOR...IN...SELECT Loop Record Access
- Record field names are automatically UP-CASED in FOR loops
- Access fields as `record.FIELD_NAME` (uppercase), not `record.field_name`
- Example: `table_rec.SOURCE_DATABASE_NAME` not `table_rec.source_database_name`

### 4. Cursor vs FOR...IN...SELECT Choice
- Use explicit `CURSOR` declarations when you need dynamic table names with `IDENTIFIER()`
- Use `FOR...IN...SELECT` for static queries with known table names
- Cannot use bind variables in CURSOR declarations - use FOR loops with IDENTIFIER() instead

### 5. Record Variable Limitations
- Record variables from FOR loops cannot be used directly in WHERE clauses of complex queries
- Extract record values to regular variables first: `LET var := record.FIELD_NAME;`
- Then use the regular variables in subsequent queries

## GET_LINEAGE Function Rules

### 6. Understanding GET_LINEAGE Output
- Returns relationship edges (SOURCE → TARGET), not just target objects
- For UPSTREAM lineage, extract SOURCE_OBJECT_* columns to get upstream objects
- For DOWNSTREAM lineage, extract TARGET_OBJECT_* columns
- Distance represents actual hops: 1 = immediate, 2 = two hops, etc.

### 7. GET_LINEAGE Limitations
- Cannot be used in LATERAL joins
- Must call individually for each column in loops
- Returns live data, not dependent on ACCOUNT_USAGE latency

## Dynamic SQL and IDENTIFIER Rules

### 8. IDENTIFIER Function Requirements
- Must be passed a single string literal or variable
- Cannot use string concatenation inside IDENTIFIER(): `IDENTIFIER(var1 || var2)` is invalid
- Pre-build concatenated strings: `LET fqn := var1 || var2; IDENTIFIER(fqn);`

### 9. Temporary Table Scoping
- Temporary tables are not visible inside EXECUTE IMMEDIATE blocks
- Use uniquely named permanent tables for dynamic SQL, then clean up
- Always include cleanup in both main logic and EXCEPTION blocks

## DDL Syntax Rules

### 10. ALTER TABLE Comment Syntax
- Single column: `ALTER TABLE table ALTER COLUMN col COMMENT 'text'`
- Multiple columns: `ALTER TABLE table MODIFY COLUMN col1 COMMENT 'text1', col2 COMMENT 'text2'`
- Never use: `ALTER TABLE table ALTER (COLUMN col SET COMMENT 'text')`

### 11. String Escaping in Dynamic SQL
- Escape single quotes in comments: `REPLACE(comment, '''', '''''')`
- Use SAFE_QUOTE() for identifier quoting: `SAFE_QUOTE(column_name)`
- Prefer CONCAT() over || in LISTAGG for complex concatenations

## Performance and Logic Rules

### 12. Comment Gathering Strategy
- Query INFORMATION_SCHEMA by specific (schema, table, column) tuples
- Avoid querying all commented columns from upstream tables
- Use column-specific filtering: `(c.table_schema, c.table_name, c.column_name) IN (...)`

### 13. JOIN Strategy for Lineage
- Use LEFT JOIN between lineage and comments to preserve all lineage paths
- Filter for valid comments in subsequent CTEs: `WHERE target_comment IS NOT NULL`
- This makes debugging easier by showing which lineage paths found no comments

### 14. Single Table Optimization
- If each RUN_ID corresponds to one table, avoid FOR loops
- Use direct SELECT...INTO for table metadata
- Simplifies variable scoping and eliminates cursor record issues

## Error Handling and Logging Rules

### 15. Comprehensive Error Context
- Log the actual SQL being executed before EXECUTE IMMEDIATE
- Include RUN_ID, table names, and column counts in error messages
- Use SYSTEM$ADD_EVENT for structured tracing with metrics

### 16. Idempotent Design
- Always filter UPDATE statements with precise conditions
- Include STATUS and APPLICATION_STATUS filters to prevent double-processing
- Design procedures to be safely re-runnable

## Testing and Debugging Rules

### 17. Test Data Requirements
- Use explicit column lists in CREATE TABLE AS SELECT for clear lineage
- Avoid SELECT * in test scripts - it doesn't break lineage but makes debugging harder
- Create multi-hop scenarios: BASE → MIDSTREAM → FINAL

### 18. Debugging Temporary Tables
- Comment out DROP TABLE statements during development
- Use uniquely named tables with UUIDs for parallel debugging
- Query intermediate tables to verify logic at each step

These rules capture the key lessons learned from debugging Snowflake Scripting syntax, 
lineage extraction, dynamic SQL generation, and stored procedure best practices.